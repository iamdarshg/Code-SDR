&lt;!-- =========================================================================
-- OpenFPGA Architecture for SDR Processing Pipeline
-- Initial skeleton for d:/CodeProjects/Code-SDR
-- ========================================================================= --&gt;
&lt;openfpga_architecture&gt;

  &lt;!-- Define circuit models for basic gates and flip-flops --&gt;
  &lt;circuit_library&gt;
    &lt;model name="nand2" type="gate" is_default="true"&gt;
      &lt;input name="in" num_pins="2"/&gt;
      &lt;output name="out" num_pins="1"/&gt;
      &lt;delay_matrix type="max" in_port="in" out_port="out"&gt;
        &lt;delay_block constraint="0" value="0"/&gt;
      &lt;/delay_matrix&gt;
    &lt;/model&gt;
    &lt;model name="nor2" type="gate"&gt;
      &lt;input name="in" num_pins="2"/&gt;
      &lt;output name="out" num_pins="1"/&gt;
      &lt;delay_matrix type="max" in_port="in" out_port="out"&gt;
        &lt;delay_block constraint="0" value="0"/&gt;
      &lt;/delay_matrix&gt;
    &lt;/model&gt;
    &lt;model name="inv" type="gate"&gt;
      &lt;input name="in" num_pins="1"/&gt;
      &lt;output name="out" num_pins="1"/&gt;
      &lt;delay_matrix type="max" in_port="in" out_port="out"&gt;
        &lt;delay_block constraint="0" value="0"/&gt;
      &lt;/delay_matrix&gt;
    &lt;/model&gt;
    &lt;model name="buf" type="gate"&gt;
      &lt;input name="in" num_pins="1"/&gt;
      &lt;output name="out" num_pins="1"/&gt;
      &lt;delay_matrix type="max" in_port="in" out_port="out"&gt;
        &lt;delay_block constraint="0" value="0"/&gt;
      &lt;/delay_matrix&gt;
    &lt;/model&gt;
    &lt;model name="dff" type="ff" is_default="true"&gt;
      &lt;input name="D" num_pins="1" is_clock_port="false"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="set" num_pins="1" is_set_port="true"/&gt;
      &lt;input name="reset" num_pins="1" is_reset_port="true"/&gt;
      &lt;output name="Q" num_pins="1"/&gt;
      &lt;delay_matrix type="max" in_port="clk" out_port="Q"&gt;
        &lt;delay_block constraint="0" value="0"/&gt;
      &lt;/delay_matrix&gt;
    &lt;/model&gt;
    &lt;!-- Model for clock_manager Verilog module --&gt;
    &lt;model name="clock_manager" type="hard_block" Verilog_netlist="verilog/clock_manager.v"&gt;
      &lt;input name="clk_100m_in" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;output name="clk_600m" num_pins="1" is_clock_port="true"/&gt;
      &lt;output name="clk_1200m_fft" num_pins="1" is_clock_port="true"/&gt;
      &lt;output name="clk_125m_eth" num_pins="1" is_clock_port="true"/&gt;
      &lt;output name="clk_250m_eth" num_pins="1" is_clock_port="true"/&gt;
      &lt;output name="clk_105m_adc" num_pins="1" is_clock_port="true"/&gt;
      &lt;output name="locked" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for adc_interface Verilog module --&gt;
    &lt;model name="adc_interface" type="hard_block" Verilog_netlist="verilog/adc_interface.v"&gt;
      &lt;input name="clk_adc" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="adc_data" num_pins="10"/&gt;
      &lt;input name="adc_valid" num_pins="1"/&gt;
      &lt;input name="adc_ovr" num_pins="1"/&gt;
      &lt;output name="adc_samples" num_pins="32"/&gt;
      &lt;output name="sample_valid" num_pins="1"/&gt;
      &lt;output name="overflow_detect" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for async_fifo Verilog module --&gt;
    &lt;model name="async_fifo" type="hard_block" Verilog_netlist="verilog/async_fifo.v"&gt;
      &lt;parameter name="WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="DEPTH" type="int" default_value="256"/&gt;
      &lt;input name="wr_clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rd_clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="wr_rst_n" num_pins="1"/&gt;
      &lt;input name="rd_rst_n" num_pins="1"/&gt;
      &lt;input name="din" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;input name="wr_en" num_pins="1"/&gt;
      &lt;input name="rd_en" num_pins="1"/&gt;
      &lt;output name="dout" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;output name="full" num_pins="1"/&gt;
      &lt;output name="empty" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for digital_downconverter Verilog module --&gt;
    &lt;model name="digital_downconverter" type="hard_block" Verilog_netlist="verilog/digital_downconverter.v"&gt;
      &lt;parameter name="WIDTH" type="int" default_value="32"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="adc_data" num_pins="32"/&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;input name="nco_sine" num_pins="16"/&gt;
      &lt;input name="nco_cosine" num_pins="16"/&gt;
      &lt;input name="gain_control" num_pins="8"/&gt;
      &lt;output name="i_component" num_pins="32"/&gt;
      &lt;output name="q_component" num_pins="32"/&gt;
      &lt;output name="ddc_valid" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for nco_generator Verilog module --&gt;
    &lt;model name="nco_generator" type="hard_block" Verilog_netlist="verilog/nco_generator.v"&gt;
      &lt;parameter name="WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="ROM_DEPTH" type="int" default_value="256"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="frequency_word" num_pins="32"/&gt;
      &lt;input name="enable" num_pins="1"/&gt;
      &lt;output name="sine_out" num_pins="16"/&gt;
      &lt;output name="cosine_out" num_pins="16"/&gt;
      &lt;output name="valid_out" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for adaptive_gain_scaler Verilog module --&gt;
    &lt;model name="adaptive_gain_scaler" type="hard_block" Verilog_netlist="verilog/adaptive_gain_scaler.v"&gt;
      &lt;parameter name="DATA_WIDTH" type="int" default_value="32"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="sample_in" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;input name="sample_valid_in" num_pins="1"/&gt;
      &lt;input name="gain_control" num_pins="8"/&gt;
      &lt;output name="sample_out" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;output name="sample_valid_out" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for cic_decimator Verilog module --&gt;
    &lt;model name="cic_decimator" type="hard_block" Verilog_netlist="verilog/cic_decimator.v"&gt;
      &lt;parameter name="INPUT_WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="OUTPUT_WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="STAGES" type="int" default_value="3"/&gt;
      &lt;parameter name="DECIMATION" type="int" default_value="8"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="data_in" num_pins="32"/&gt; &lt;!-- Using default INPUT_WIDTH --&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;output name="data_out" num_pins="32"/&gt; &lt;!-- Using default OUTPUT_WIDTH --&gt;
      &lt;output name="output_valid" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for compensation_filter Verilog module --&gt;
    &lt;model name="compensation_filter" type="hard_block" Verilog_netlist="verilog/compensation_filter.v"&gt;
      &lt;parameter name="WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="COEFF_WIDTH" type="int" default_value="16"/&gt;
      &lt;parameter name="TAPS" type="int" default_value="8"/&gt;
      &lt;parameter name="DECIMATION" type="int" default_value="8"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="data_in" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;output name="data_out" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;output name="output_valid" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for hamming_window Verilog module --&gt;
    &lt;model name="hamming_window" type="hard_block" Verilog_netlist="verilog/hamming_window.v"&gt;
      &lt;parameter name="WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="FFT_SIZE" type="int" default_value="1024"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="data_in" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;output name="data_out" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;output name="output_valid" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for fft_processor Verilog module --&gt;
    &lt;model name="fft_processor" type="hard_block" Verilog_netlist="verilog/fft_processor.v"&gt;
      &lt;parameter name="FFT_SIZE" type="int" default_value="4096"/&gt;
      &lt;parameter name="DATA_WIDTH" type="int" default_value="24"/&gt;
      &lt;parameter name="SCALE_FACTOR" type="int" default_value="24"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="real_in" num_pins="24"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;input name="imag_in" num_pins="24"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;output name="real_out" num_pins="24"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;output name="imag_out" num_pins="24"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;output name="fft_valid" num_pins="1"/&gt;
      &lt;output name="fft_index" num_pins="12"/&gt;
      &lt;output name="overflow_flag" num_pins="1"/&gt;
      &lt;output name="processing_active" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for udp_ip_stack Verilog module --&gt;
    &lt;model name="udp_ip_stack" type="hard_block" Verilog_netlist="verilog/udp_ip_stack.v"&gt;
      &lt;parameter name="DATA_WIDTH" type="int" default_value="32"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="app_data" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;input name="app_len" num_pins="16"/&gt;
      &lt;input name="app_valid" num_pins="1"/&gt;
      &lt;input name="src_ip" num_pins="32"/&gt;
      &lt;input name="dst_ip" num_pins="32"/&gt;
      &lt;input name="src_port" num_pins="16"/&gt;
      &lt;input name="dst_port" num_pins="16"/&gt;
      &lt;output name="app_ready" num_pins="1"/&gt;
      &lt;output name="mac_data" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;output name="mac_len" num_pins="16"/&gt;
      &lt;output name="mac_valid" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for ethernet_mac Verilog module --&gt;
    &lt;model name="ethernet_mac" type="hard_block" Verilog_netlist="verilog/ethernet_mac.v"&gt;
      &lt;parameter name="DATA_WIDTH" type="int" default_value="32"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="gmii_rx_d" num_pins="8"/&gt;
      &lt;input name="gmii_rx_dv" num_pins="1"/&gt;
      &lt;input name="gmii_rx_er" num_pins="1"/&gt;
      &lt;input name="packet_data" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;input name="packet_len" num_pins="16"/&gt;
      &lt;input name="packet_valid" num_pins="1"/&gt;
      &lt;input name="rx_packet_ack" num_pins="1"/&gt;
      &lt;output name="gmii_tx_d" num_pins="8"/&gt;
      &lt;output name="gmii_tx_en" num_pins="1"/&gt;
      &lt;output name="gmii_tx_er" num_pins="1"/&gt;
      &lt;output name="packet_ack" num_pins="1"/&gt;
      &lt;output name="rx_packet_data" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;output name="rx_packet_len" num_pins="16"/&gt;
      &lt;output name="rx_packet_valid" num_pins="1"/&gt;
      &lt;output name="link_status" num_pins="1"/&gt;
      &lt;output name="packet_counter" num_pins="32"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for rp2040_interface Verilog module --&gt;
    &lt;model name="rp2040_interface" type="hard_block" Verilog_netlist="verilog/rp2040_interface.v"&gt;
      &lt;parameter name="ADDR_WIDTH" type="int" default_value="16"/&gt;
      &lt;parameter name="DATA_WIDTH" type="int" default_value="32"/&gt;
      &lt;input name="spi_clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="spi_mosi" num_pins="1"/&gt;
      &lt;input name="spi_cs_n" num_pins="1"/&gt;
      &lt;output name="spi_miso" num_pins="1"/&gt;
      &lt;output name="frequency_word" num_pins="32"/&gt;
      &lt;output name="gain_control" num_pins="8"/&gt;
      &lt;output name="filter_select" num_pins="4"/&gt;
      &lt;output name="enable_control" num_pins="1"/&gt;
      &lt;output name="streaming_mode" num_pins="1"/&gt;
      &lt;output name="bandwidth_limit" num_pins="8"/&gt;
      &lt;output name="processing_mode" num_pins="3"/&gt;
      &lt;output name="modulation_type" num_pins="8"/&gt;
      &lt;output name="filter_bandwidth" num_pins="8"/&gt;
      &lt;output name="clock_gating_en" num_pins="1"/&gt;
      &lt;output name="thermal_scaling" num_pins="8"/&gt;
      &lt;output name="resource_opt_en" num_pins="1"/&gt;
      &lt;output name="power_profile" num_pins="8"/&gt;
      &lt;input name="status_reg" num_pins="16"/&gt;
      &lt;input name="pll_locked" num_pins="1"/&gt;
      &lt;input name="eth_link_status" num_pins="1"/&gt;
    &lt;/model&gt;
  &lt;/circuit_library&gt;

  &lt;!-- Define clocks --&gt;
  &lt;clocks&gt;
    &lt;clock name="clk_100m_in"/&gt;
    &lt;clock name="adc_clock"/&gt;
    &lt;clock name="clk_600m"/&gt;
    &lt;clock name="clk_1200m_fft"/&gt;
    &lt;clock name="clk_125m_eth_standard"/&gt;
    &lt;clock name="clk_250m_eth_boosted"/&gt;
    &lt;clock name="spi_clk"/&gt;
  &lt;/clocks&gt;

  &lt;!-- Define complex block types (CLBs, I/O, memories, custom IPs) --&gt;
  &lt;block_types&gt;
    &lt;!-- I/O block --&&gt;
    &lt;pb_type name="io" num_pb="1" class="inpad" is_primitive="true"&gt;
      &lt;port name="inpad" num_pins="1" is_input="true"/&gt;
    &lt;/pb_type&gt;
    &lt;pb_type name="io" num_pb="1" class="outpad" is_primitive="true"&gt;
      &lt;port name="outpad" num_pins="1" is_output="true"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Generic CLB placeholder --&gt;
    &lt;pb_type name="CLB" num_pb="1"&gt;
      &lt;port name="in" num_pins="16" is_input="true"/&gt;
      &lt;port name="out" num_pins="8" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;pb_type name="lut" num_pb="1" class="lut" is_primitive="true"&gt;
          &lt;input name="in" num_pins="6"/&gt;
          &lt;output name="out" num_pins="1"/&gt;
          &lt;mode name="default"&gt;
            &lt;model_list&gt;
              &lt;model name="nand2" mapping="in" out_port="out"/&gt;
            &lt;/model_list&gt;
          &lt;/mode&gt;
        &lt;/pb_type&gt;
        &lt;pb_type name="ff" num_pb="1" class="ff" is_primitive="true"&gt;
          &lt;input name="D" num_pins="1"/&gt;
          &lt;output name="Q" num_pins="1"/&gt;
          &lt;clock name="clk"/&gt;
          &lt;mode name="default"&gt;
            &lt;model_list&gt;
              &lt;model name="dff" mapping="D" out_port="Q"/&gt;
            &lt;/model_list&gt;
          &lt;/mode&gt;
        &lt;/pb_type&gt;
        &lt;interconnect&gt;
          &lt;direct name="lut_to_ff" input="lut.out" output="ff.D"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP blocks --&gt;
    &lt;pb_type name="clock_manager_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk_100m_in" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="clk_600m" num_pins="1" is_output="true" is_clock="true"/&gt;
      &lt;port name="clk_1200m_fft" num_pins="1" is_output="true" is_clock="true"/&gt;
      &lt;port name="clk_125m_eth" num_pins="1" is_output="true" is_clock="true"/&gt;
      &lt;port name="clk_250m_eth" num_pins="1" is_output="true" is_clock="true"/&gt;
      &lt;port name="clk_105m_adc" num_pins="1" is_output="true" is_clock="true"/&gt;
      &lt;port name="locked" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="clock_manager"/&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_100m_in_to_model" input="clock_manager_block.clk_100m_in" output="clock_manager.clk_100m_in"/&gt;
          &lt;direct name="rst_n_to_model" input="clock_manager_block.rst_n" output="clock_manager.rst_n"/&gt;
          &lt;direct name="model_to_clk_600m" input="clock_manager.clk_600m" output="clock_manager_block.clk_600m"/&gt;
          &lt;direct name="model_to_clk_1200m_fft" input="clock_manager.clk_1200m_fft" output="clock_manager_block.clk_1200m_fft"/&gt;
          &lt;direct name="model_to_clk_125m_eth" input="clock_manager.clk_125m_eth" output="clock_manager_block.clk_125m_eth"/&gt;
          &lt;direct name="model_to_clk_250m_eth" input="clock_manager.clk_250m_eth" output="clock_manager_block.clk_250m_eth"/&gt;
          &lt;direct name="model_to_clk_105m_adc" input="clock_manager.clk_105m_adc" output="clock_manager_block.clk_105m_adc"/&gt;
          &lt;direct name="model_to_locked" input="clock_manager.locked" output="clock_manager_block.locked"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for ADC Interface --&gt;
    &lt;pb_type name="adc_interface_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk_adc" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="adc_data" num_pins="10" is_input="true"/&gt;
      &lt;port name="adc_valid" num_pins="1" is_input="true"/&gt;
      &lt;port name="adc_ovr" num_pins="1" is_input="true"/&gt;
      &lt;port name="adc_samples" num_pins="32" is_output="true"/&gt;
      &lt;port name="sample_valid" num_pins="1" is_output="true"/&gt;
      &lt;port name="overflow_detect" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="adc_interface"/&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_adc_to_model" input="adc_interface_block.clk_adc" output="adc_interface.clk_adc"/&gt;
          &lt;direct name="rst_n_to_model" input="adc_interface_block.rst_n" output="adc_interface.rst_n"/&gt;
          &lt;direct name="adc_data_to_model" input="adc_interface_block.adc_data" output="adc_interface.adc_data"/&gt;
          &lt;direct name="adc_valid_to_model" input="adc_interface_block.adc_valid" output="adc_interface.adc_valid"/&gt;
          &lt;direct name="adc_ovr_to_model" input="adc_interface_block.adc_ovr" output="adc_interface.adc_ovr"/&gt;
          &lt;direct name="model_to_adc_samples" input="adc_interface.adc_samples" output="adc_interface_block.adc_samples"/&gt;
          &lt;direct name="model_to_sample_valid" input="adc_interface.sample_valid" output="adc_interface_block.sample_valid"/&gt;
          &lt;direct name="model_to_overflow_detect" input="adc_interface.overflow_detect" output="adc_interface_block.overflow_detect"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Asynchronous FIFO --&gt;
    &lt;pb_type name="async_fifo_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="wr_clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rd_clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="wr_rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="rd_rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="din" num_pins="32" is_input="true"/&gt;
      &lt;port name="wr_en" num_pins="1" is_input="true"/&gt;
      &lt;port name="rd_en" num_pins="1" is_input="true"/&gt;
      &lt;port name="dout" num_pins="32" is_output="true"/&gt;
      &lt;port name="full" num_pins="1" is_output="true"/&gt;
      &lt;port name="empty" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="async_fifo"&gt;
            &lt;param name="WIDTH" value="32"/&gt;
            &lt;param name="DEPTH" value="256"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="wr_clk_to_model" input="async_fifo_block.wr_clk" output="async_fifo.wr_clk"/&gt;
          &lt;direct name="rd_clk_to_model" input="async_fifo_block.rd_clk" output="async_fifo.rd_clk"/&gt;
          &lt;direct name="wr_rst_n_to_model" input="async_fifo_block.wr_rst_n" output="async_fifo.wr_rst_n"/&gt;
          &lt;direct name="rd_rst_n_to_model" input="async_fifo_block.rd_rst_n" output="async_fifo.rd_rst_n"/&gt;
          &lt;direct name="din_to_model" input="async_fifo_block.din" output="async_fifo.din"/&gt;
          &lt;direct name="wr_en_to_model" input="async_fifo_block.wr_en" output="async_fifo.wr_en"/&gt;
          &lt;direct name="rd_en_to_model" input="async_fifo_block.rd_en" output="async_fifo.rd_en"/&gt;
          &lt;direct name="model_to_dout" input="async_fifo.dout" output="async_fifo_block.dout"/&gt;
          &lt;direct name="model_to_full" input="async_fifo.full" output="async_fifo_block.full"/&gt;
          &lt;direct name="model_to_empty" input="async_fifo.empty" output="async_fifo_block.empty"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Digital Downconverter --&gt;
    &lt;pb_type name="digital_downconverter_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="adc_data" num_pins="32" is_input="true"/&gt;
      &lt;port name="data_valid" num_pins="1" is_input="true"/&gt;
      &lt;input name="nco_sine" num_pins="16"/&gt;
      &lt;input name="nco_cosine" num_pins="16"/&gt;
      &lt;input name="gain_control" num_pins="8"/&gt;
      &lt;output name="i_component" num_pins="32"/&gt;
      &lt;output name="q_component" num_pins="32"/&gt;
      &lt;output name="ddc_valid" num_pins="1"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for NCO Generator --&gt;
    &lt;pb_type name="nco_generator_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="frequency_word" num_pins="32" is_input="true"/&gt;
      &lt;port name="enable" num_pins="1" is_input="true"/&gt;
      &lt;output name="sine_out" num_pins="16" is_output="true"/&gt;
      &lt;output name="cosine_out" num_pins="16" is_output="true"/&gt;
      &lt;output name="valid_out" num_pins="1" is_output="true"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Adaptive Gain Scaler --&gt;
    &lt;pb_type name="adaptive_gain_scaler_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="sample_in" num_pins="32" is_input="true"/&gt;
      &lt;port name="sample_valid_in" num_pins="1" is_input="true"/&gt;
      &lt;port name="gain_control" num_pins="8" is_input="true"/&gt;
      &lt;output name="sample_out" num_pins="32" is_output="true"/&gt;
      &lt;output name="sample_valid_out" num_pins="1" is_output="true"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for CIC Decimator --&gt;
    &lt;pb_type name="cic_decimator_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="data_in" num_pins="32" is_input="true"/&gt;
      &lt;port name="data_valid" num_pins="1" is_input="true"/&gt;
      &lt;output name="data_out" num_pins="32" is_output="true"/&gt;
      &lt;output name="output_valid" num_pins="1" is_output="true"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Compensation Filter --&gt;
    &lt;pb_type name="compensation_filter_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="data_in" num_pins="32" is_input="true"/&gt;
      &lt;port name="data_valid" num_pins="1" is_input="true"/&gt;
      &lt;output name="data_out" num_pins="32" is_output="true"/&gt;
      &lt;output name="output_valid" num_pins="1" is_output="true"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Hamming Window --&gt;
    &lt;pb_type name="hamming_window_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="data_in" num_pins="32" is_input="true"/&gt;
      &lt;port name="data_valid" num_pins="1" is_input="true"/&gt;
      &lt;output name="data_out" num_pins="32" is_output="true"/&gt;
      &lt;output name="output_valid" num_pins="1" is_output="true"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for FFT Processor --&gt;
    &lt;pb_type name="fft_processor_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="real_in" num_pins="24" is_input="true"/&gt;
      &lt;input name="imag_in" num_pins="24"/&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;output name="real_out" num_pins="24" is_output="true"/&gt;
      &lt;output name="imag_out" num_pins="24" is_output="true"/&gt;
      &lt;output name="fft_valid" num_pins="1" is_output="true"/&gt;
      &lt;output name="fft_index" num_pins="12" is_output="true"/&gt;
      &lt;output name="overflow_flag" num_pins="1" is_output="true"/&gt;
      &lt;output name="processing_active" num_pins="1" is_output="true"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for UDP/IP Stack --&gt;
    &lt;pb_type name="udp_ip_stack_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="app_data" num_pins="32" is_input="true"/&gt;
      &lt;input name="app_len" num_pins="16"/&gt;
      &lt;input name="app_valid" num_pins="1"/&gt;
      &lt;input name="src_ip" num_pins="32"/&gt;
      &lt;input name="dst_ip" num_pins="32"/&gt;
      &lt;input name="src_port" num_pins="16"/&gt;
      &lt;input name="dst_port" num_pins="16"/&gt;
      &lt;output name="app_ready" num_pins="1" is_output="true"/&gt;
      &lt;output name="mac_data" num_pins="32" is_output="true"/&gt;
      &lt;output name="mac_len" num_pins="16" is_output="true"/&gt;
      &lt;output name="mac_valid" num_pins="1" is_output="true"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Ethernet MAC Layer --&gt;
    &lt;pb_type name="ethernet_mac_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="gmii_rx_d" num_pins="8" is_input="true"/&gt;
      &lt;input name="gmii_rx_dv" num_pins="1"/&gt;
      &lt;input name="gmii_rx_er" num_pins="1"/&gt;
      &lt;input name="packet_data" num_pins="32"/&gt;
      &lt;input name="packet_len" num_pins="16"/&gt;
      &lt;input name="packet_valid" num_pins="1"/&gt;
      &lt;input name="rx_packet_ack" num_pins="1"/&gt;
      &lt;output name="gmii_tx_d" num_pins="8" is_output="true"/&gt;
      &lt;output name="gmii_tx_en" num_pins="1" is_output="true"/&gt;
      &lt;output name="gmii_tx_er" num_pins="1" is_output="true"/&gt;
      &lt;output name="packet_ack" num_pins="1" is_output="true"/&gt;
      &lt;output name="rx_packet_data" num_pins="32" is_output="true"/&gt;
      &lt;output name="rx_packet_len" num_pins="16" is_output="true"/&gt;
      &lt;output name="rx_packet_valid" num_pins="1" is_output="true"/&gt;
      &lt;output name="link_status" num_pins="1" is_output="true"/&gt;
      &lt;output name="packet_counter" num_pins="32" is_output="true"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for RP2040 Interface --&gt;
    &lt;pb_type name="rp2040_interface_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="spi_clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;input name="spi_mosi" num_pins="1"/&gt;
      &lt;input name="spi_cs_n" num_pins="1"/&gt;
      &lt;output name="spi_miso" num_pins="1"/&gt;
      &lt;output name="frequency_word" num_pins="32"/&gt;
      &lt;output name="gain_control" num_pins="8"/&gt;
      &lt;output name="filter_select" num_pins="4"/&gt;
      &lt;output name="enable_control" num_pins="1"/&gt;
      &lt;output name="streaming_mode" num_pins="1"/&gt;
      &lt;output name="bandwidth_limit" num_pins="8"/&gt;
      &lt;output name="processing_mode" num_pins="3"/&gt;
      &lt;output name="modulation_type" num_pins="8"/&gt;
      &lt;output name="filter_bandwidth" num_pins="8"/&gt;
      &lt;output name="clock_gating_en" num_pins="1"/&gt;
      &lt;output name="thermal_scaling" num_pins="8"/&gt;
      &lt;output name="resource_opt_en" num_pins="1"/&gt;
      &lt;output name="power_profile" num_pins="8"/&gt;
      &lt;input name="status_reg" num_pins="16"/&gt;
      &lt;input name="pll_locked" num_pins="1"/&gt;
      &lt;input name="eth_link_status" num_pins="1"/&gt;
    &lt;/pb_type&gt;
  &lt;/block_types&gt;

  &lt;!-- Define FPGA grid layout --&gt;
  &lt;layout&gt;
    &lt;fixed_layout name="4x4_grid" priority="1" num_rows="4" num_cols="4"&gt;
      &lt;apply block_type="io" num_instances="1" side="left"  startx="0" starty="1"/&gt;
      &lt;apply block_type="io" num_instances="1" side="right" startx="4" starty="1"/&gt;
      &lt;apply block_type="CLB" num_instances="1" startx="1" starty="1"/&gt;
      &lt;apply block_type="CLB" num_instances="1" startx="2" starty="1"/&gt;
      &lt;apply block_type="CLB" num_instances="1" startx="1" starty="2"/&gt;
      &lt;apply block_type="CLB" num_instances="1" startx="2" starty="2"/&gt;
    &lt;/fixed_layout&gt;
  &lt;/layout&gt;

  &lt;!-- Define global routing architecture --&gt;
  &lt;segment_library&gt;
    &lt;segment name="L4" length="4" type="bidir" R_per_meter="80" C_per_meter="2.5e-14" freq_typical="100e6"&gt;
      &lt;mux name="mux_2" type="full_mux"/&gt;
      &lt;driver name="tgate" type="pmos"/&gt;
      &lt;sb_switch name="0" type="pass_gate"/&gt;
      &lt;cb_switch name="0" type="pass_gate"/&gt;
    &lt;/segment&gt;
  &lt;/segment_library&gt;
  
  &lt;switch_library&gt;
    &lt;switch name="0" type="mux" R="50" Cin="0" Cout="0" Tdel="0"/&gt;
  &lt;/switch_library&gt;
  
  &lt;tool_options&gt;
    &lt;sdc_options&gt;
      &lt;time_unit value="ns"/&gt;
    &lt;/sdc_options&gt;
  &lt;/tool_options&gt;

&lt;/openfpga_architecture&gt;
