&lt;!-- =========================================================================
-- OpenFPGA Architecture for SDR Processing Pipeline
-- Initial skeleton for d:/CodeProjects/Code-SDR
-- ========================================================================= --&gt;
&lt;openfpga_architecture&gt;

  &lt;!-- Define circuit models for basic gates and flip-flops --&gt;
  &lt;circuit_library&gt;
    &lt;model name="nand2" type="gate" is_default="true"&gt;
      &lt;input name="in" num_pins="2"/&gt;
      &lt;output name="out" num_pins="1"/&gt;
      &lt;delay_matrix type="max" in_port="in" out_port="out"&gt;
        &lt;delay_block constraint="0" value="0"/&gt;
      &lt;/delay_matrix&gt;
    &lt;/model&gt;
    &lt;model name="nor2" type="gate"&gt;
      &lt;input name="in" num_pins="2"/&gt;
      &lt;output name="out" num_pins="1"/&gt;
      &lt;delay_matrix type="max" in_port="in" out_port="out"&gt;
        &lt;delay_block constraint="0" value="0"/&gt;
      &lt;/delay_matrix&gt;
    &lt;/model&gt;
    &lt;model name="inv" type="gate"&gt;
      &lt;input name="in" num_pins="1"/&gt;
      &lt;output name="out" num_pins="1"/&gt;
      &lt;delay_matrix type="max" in_port="in" out_port="out"&gt;
        &lt;delay_block constraint="0" value="0"/&gt;
      &lt;/delay_matrix&gt;
    &lt;/model&gt;
    &lt;model name="buf" type="gate"&gt;
      &lt;input name="in" num_pins="1"/&gt;
      &lt;output name="out" num_pins="1"/&gt;
      &lt;delay_matrix type="max" in_port="in" out_port="out"&gt;
        &lt;delay_block constraint="0" value="0"/&gt;
      &lt;/delay_matrix&gt;
    &lt;/model&gt;
    &lt;model name="dff" type="ff" is_default="true"&gt;
      &lt;input name="D" num_pins="1" is_clock_port="false"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="set" num_pins="1" is_set_port="true"/&gt;
      &lt;input name="reset" num_pins="1" is_reset_port="true"/&gt;
      &lt;output name="Q" num_pins="1"/&gt;
      &lt;delay_matrix type="max" in_port="clk" out_port="Q"&gt;
        &lt;delay_block constraint="0" value="0"/&gt;
      &lt;/delay_matrix&gt;
    &lt;/model&gt;
    &lt;!-- Model for clock_manager Verilog module --&gt;
    &lt;model name="clock_manager" type="hard_block" Verilog_netlist="verilog/clock_manager.v"&gt;
      &lt;input name="clk_100m_in" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;output name="clk_600m" num_pins="1" is_clock_port="true"/&gt;
      &lt;output name="clk_1200m_fft" num_pins="1" is_clock_port="true"/&gt;
      &lt;output name="clk_125m_eth" num_pins="1" is_clock_port="true"/&gt;
      &lt;output name="clk_250m_eth" num_pins="1" is_clock_port="true"/&gt;
      &lt;output name="clk_105m_adc" num_pins="1" is_clock_port="true"/&gt;
      &lt;output name="locked" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for adc_interface Verilog module --&gt;
    &lt;model name="adc_interface" type="hard_block" Verilog_netlist="verilog/adc_interface.v"&gt;
      &lt;input name="clk_adc" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="adc_data" num_pins="10"/&gt;
      &lt;input name="adc_valid" num_pins="1"/&gt;
      &lt;input name="adc_ovr" num_pins="1"/&gt;
      &lt;output name="adc_samples" num_pins="32"/&gt;
      &lt;output name="sample_valid" num_pins="1"/&gt;
      &lt;output name="overflow_detect" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for async_fifo Verilog module --&gt;
    &lt;model name="async_fifo" type="hard_block" Verilog_netlist="verilog/async_fifo.v"&gt;
      &lt;parameter name="WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="DEPTH" type="int" default_value="256"/&gt;
      &lt;input name="wr_clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rd_clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="wr_rst_n" num_pins="1"/&gt;
      &lt;input name="rd_rst_n" num_pins="1"/&gt;
      &lt;input name="din" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;input name="wr_en" num_pins="1"/&gt;
      &lt;input name="rd_en" num_pins="1"/&gt;
      &lt;output name="dout" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;output name="full" num_pins="1"/&gt;
      &lt;output name="empty" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for digital_downconverter Verilog module --&gt;
    &lt;model name="digital_downconverter" type="hard_block" Verilog_netlist="verilog/digital_downconverter.v"&gt;
      &lt;parameter name="WIDTH" type="int" default_value="32"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="adc_data" num_pins="32"/&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;input name="nco_sine" num_pins="16"/&gt;
      &lt;input name="nco_cosine" num_pins="16"/&gt;
      &lt;input name="gain_control" num_pins="8"/&gt;
      &lt;output name="i_component" num_pins="32"/&gt;
      &lt;output name="q_component" num_pins="32"/&gt;
      &lt;output name="ddc_valid" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for nco_generator Verilog module --&gt;
    &lt;model name="nco_generator" type="hard_block" Verilog_netlist="verilog/nco_generator.v"&gt;
      &lt;parameter name="WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="ROM_DEPTH" type="int" default_value="256"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="frequency_word" num_pins="32"/&gt;
      &lt;input name="enable" num_pins="1"/&gt;
      &lt;output name="sine_out" num_pins="16"/&gt;
      &lt;output name="cosine_out" num_pins="16"/&gt;
      &lt;output name="valid_out" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for adaptive_gain_scaler Verilog module --&gt;
    &lt;model name="adaptive_gain_scaler" type="hard_block" Verilog_netlist="verilog/adaptive_gain_scaler.v"&gt;
      &lt;parameter name="DATA_WIDTH" type="int" default_value="32"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="sample_in" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;input name="sample_valid_in" num_pins="1"/&gt;
      &lt;input name="gain_control" num_pins="8"/&gt;
      &lt;output name="sample_out" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;output name="sample_valid_out" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for cic_decimator Verilog module --&gt;
    &lt;model name="cic_decimator" type="hard_block" Verilog_netlist="verilog/cic_decimator.v"&gt;
      &lt;parameter name="INPUT_WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="OUTPUT_WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="STAGES" type="int" default_value="3"/&gt;
      &lt;parameter name="DECIMATION" type="int" default_value="8"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="data_in" num_pins="32"/&gt; &lt;!-- Using default INPUT_WIDTH --&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;output name="data_out" num_pins="32"/&gt; &lt;!-- Using default OUTPUT_WIDTH --&gt;
      &lt;output name="output_valid" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for compensation_filter Verilog module --&gt;
    &lt;model name="compensation_filter" type="hard_block" Verilog_netlist="verilog/compensation_filter.v"&gt;
      &lt;parameter name="WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="COEFF_WIDTH" type="int" default_value="16"/&gt;
      &lt;parameter name="TAPS" type="int" default_value="8"/&gt;
      &lt;parameter name="DECIMATION" type="int" default_value="8"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="data_in" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;output name="data_out" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;output name="output_valid" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for hamming_window Verilog module --&gt;
    &lt;model name="hamming_window" type="hard_block" Verilog_netlist="verilog/hamming_window.v"&gt;
      &lt;parameter name="WIDTH" type="int" default_value="32"/&gt;
      &lt;parameter name="FFT_SIZE" type="int" default_value="1024"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="data_in" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;output name="data_out" num_pins="32"/&gt; &lt;!-- Using default WIDTH --&gt;
      &lt;output name="output_valid" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for fft_processor Verilog module --&gt;
    &lt;model name="fft_processor" type="hard_block" Verilog_netlist="verilog/fft_processor.v"&gt;
      &lt;parameter name="FFT_SIZE" type="int" default_value="4096"/&gt;
      &lt;parameter name="DATA_WIDTH" type="int" default_value="24"/&gt;
      &lt;parameter name="SCALE_FACTOR" type="int" default_value="24"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="real_in" num_pins="24"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;input name="imag_in" num_pins="24"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;input name="data_valid" num_pins="1"/&gt;
      &lt;output name="real_out" num_pins="24"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;output name="imag_out" num_pins="24"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;output name="fft_valid" num_pins="1"/&gt;
      &lt;output name="fft_index" num_pins="12"/&gt;
      &lt;output name="overflow_flag" num_pins="1"/&gt;
      &lt;output name="processing_active" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for udp_ip_stack Verilog module --&gt;
    &lt;model name="udp_ip_stack" type="hard_block" Verilog_netlist="verilog/udp_ip_stack.v"&gt;
      &lt;parameter name="DATA_WIDTH" type="int" default_value="32"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="app_data" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;input name="app_len" num_pins="16"/&gt;
      &lt;input name="app_valid" num_pins="1"/&gt;
      &lt;input name="src_ip" num_pins="32"/&gt;
      &lt;input name="dst_ip" num_pins="32"/&gt;
      &lt;input name="src_port" num_pins="16"/&gt;
      &lt;input name="dst_port" num_pins="16"/&gt;
      &lt;output name="app_ready" num_pins="1"/&gt;
      &lt;output name="mac_data" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;output name="mac_len" num_pins="16"/&gt;
      &lt;output name="mac_valid" num_pins="1"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for ethernet_mac Verilog module --&gt;
    &lt;model name="ethernet_mac" type="hard_block" Verilog_netlist="verilog/ethernet_mac.v"&gt;
      &lt;parameter name="DATA_WIDTH" type="int" default_value="32"/&gt;
      &lt;input name="clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="rst_n" num_pins="1"/&gt;
      &lt;input name="gmii_rx_d" num_pins="8"/&gt;
      &lt;input name="gmii_rx_dv" num_pins="1"/&gt;
      &lt;input name="gmii_rx_er" num_pins="1"/&gt;
      &lt;input name="packet_data" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;input name="packet_len" num_pins="16"/&gt;
      &lt;input name="packet_valid" num_pins="1"/&gt;
      &lt;input name="rx_packet_ack" num_pins="1"/&gt;
      &lt;output name="gmii_tx_d" num_pins="8"/&gt;
      &lt;output name="gmii_tx_en" num_pins="1"/&gt;
      &lt;output name="gmii_tx_er" num_pins="1"/&gt;
      &lt;output name="packet_ack" num_pins="1"/&gt;
      &lt;output name="rx_packet_data" num_pins="32"/&gt; &lt;!-- Using default DATA_WIDTH --&gt;
      &lt;output name="rx_packet_len" num_pins="16"/&gt;
      &lt;output name="rx_packet_valid" num_pins="1"/&gt;
      &lt;output name="link_status" num_pins="1"/&gt;
      &lt;output name="packet_counter" num_pins="32"/&gt;
    &lt;/model&gt;
    &lt;!-- Model for rp2040_interface Verilog module --&gt;
    &lt;model name="rp2040_interface" type="hard_block" Verilog_netlist="verilog/rp2040_interface.v"&gt;
      &lt;parameter name="ADDR_WIDTH" type="int" default_value="16"/&gt;
      &lt;parameter name="DATA_WIDTH" type="int" default_value="32"/&gt;
      &lt;input name="spi_clk" num_pins="1" is_clock_port="true"/&gt;
      &lt;input name="spi_mosi" num_pins="1"/&gt;
      &lt;input name="spi_cs_n" num_pins="1"/&gt;
      &lt;output name="spi_miso" num_pins="1"/&gt;
      &lt;output name="frequency_word" num_pins="32"/&gt;
      &lt;output name="gain_control" num_pins="8"/&gt;
      &lt;output name="filter_select" num_pins="4"/&gt;
      &lt;output name="enable_control" num_pins="1"/&gt;
      &lt;output name="streaming_mode" num_pins="1"/&gt;
      &lt;output name="bandwidth_limit" num_pins="8"/&gt;
      &lt;output name="processing_mode" num_pins="3"/&gt;
      &lt;output name="modulation_type" num_pins="8"/&gt;
      &lt;output name="filter_bandwidth" num_pins="8"/&gt;
      &lt;output name="clock_gating_en" num_pins="1"/&gt;
      &lt;output name="thermal_scaling" num_pins="8"/&gt;
      &lt;output name="resource_opt_en" num_pins="1"/&gt;
      &lt;output name="power_profile" num_pins="8"/&gt;
      &lt;input name="status_reg" num_pins="16"/&gt;
      &lt;input name="pll_locked" num_pins="1"/&gt;
      &lt;input name="eth_link_status" num_pins="1"/&gt;
    &lt;/model&gt;
  &lt;/circuit_library&gt;

  &lt;!-- Define clocks --&gt;
  &lt;clocks&gt;
    &lt;clock name="clk_100m_in"/&gt;
    &lt;clock name="adc_clock"/&gt;
    &lt;clock name="clk_600m"/&gt;
    &lt;clock name="clk_1200m_fft"/&gt;
    &lt;clock name="clk_125m_eth_standard"/&gt;
    &lt;clock name="clk_250m_eth_boosted"/&gt;
    &lt;clock name="spi_clk"/&gt;
  &lt;/clocks&gt;

  &lt;!-- Define complex block types (CLBs, I/O, memories, custom IPs) --&gt;
  &lt;block_types&gt;
    &lt;!-- I/O block --&gt;
    &lt;pb_type name="io" num_pb="1" class="inpad" is_primitive="true"&gt;
      &lt;port name="inpad" num_pins="1" is_input="true"/&gt;
    &lt;/pb_type&gt;
    &lt;pb_type name="io" num_pb="1" class="outpad" is_primitive="true"&gt;
      &lt;port name="outpad" num_pins="1" is_output="true"/&gt;
    &lt;/pb_type&gt;

    &lt;!-- Generic CLB placeholder --&gt;
    &lt;pb_type name="CLB" num_pb="1"&gt;
      &lt;port name="in" num_pins="16" is_input="true"/&gt;
      &lt;port name="out" num_pins="8" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;pb_type name="lut" num_pb="1" class="lut" is_primitive="true"&gt;
          &lt;input name="in" num_pins="6"/&gt;
          &lt;output name="out" num_pins="1"/&gt;
          &lt;mode name="default"&gt;
            &lt;model_list&gt;
              &lt;model name="nand2" mapping="in" out_port="out"/&gt;
            &lt;/model_list&gt;
          &lt;/mode&gt;
        &lt;/pb_type&gt;
        &lt;pb_type name="ff" num_pb="1" class="ff" is_primitive="true"&gt;
          &lt;input name="D" num_pins="1"/&gt;
          &lt;output name="Q" num_pins="1"/&gt;
          &lt;clock name="clk"/&gt;
          &lt;mode name="default"&gt;
            &lt;model_list&gt;
              &lt;model name="dff" mapping="D" out_port="Q"/&gt;
            &lt;/model_list&gt;
          &lt;/mode&gt;
        &lt;/pb_type&gt;
        &lt;interconnect&gt;
          &lt;direct name="lut_to_ff" input="lut.out" output="ff.D"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP blocks --&gt;
    &lt;pb_type name="clock_manager_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk_100m_in" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="clk_600m" num_pins="1" is_output="true" is_clock="true"/&gt;
      &lt;port name="clk_1200m_fft" num_pins="1" is_output="true" is_clock="true"/&gt;
      &lt;port name="clk_125m_eth" num_pins="1" is_output="true" is_clock="true"/&gt;
      &lt;port name="clk_250m_eth" num_pins="1" is_output="true" is_clock="true"/&gt;
      &lt;port name="clk_105m_adc" num_pins="1" is_output="true" is_clock="true"/&gt;
      &lt;port name="locked" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="clock_manager"/&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_100m_in_to_model" input="clock_manager_block.clk_100m_in" output="clock_manager.clk_100m_in"/&gt;
          &lt;direct name="rst_n_to_model" input="clock_manager_block.rst_n" output="clock_manager.rst_n"/&gt;
          &lt;direct name="model_to_clk_600m" input="clock_manager.clk_600m" output="clock_manager_block.clk_600m"/&gt;
          &lt;direct name="model_to_clk_1200m_fft" input="clock_manager.clk_1200m_fft" output="clock_manager_block.clk_1200m_fft"/&gt;
          &lt;direct name="model_to_clk_125m_eth" input="clock_manager.clk_125m_eth" output="clock_manager_block.clk_125m_eth"/&gt;
          &lt;direct name="model_to_clk_250m_eth" input="clock_manager.clk_250m_eth" output="clock_manager_block.clk_250m_eth"/&gt;
          &lt;direct name="model_to_clk_105m_adc" input="clock_manager.clk_105m_adc" output="clock_manager_block.clk_105m_adc"/&gt;
          &lt;direct name="model_to_locked" input="clock_manager.locked" output="clock_manager_block.locked"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for ADC Interface --&gt;
    &lt;pb_type name="adc_interface_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk_adc" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="adc_data" num_pins="10" is_input="true"/&gt;
      &lt;port name="adc_valid" num_pins="1" is_input="true"/&gt;
      &lt;port name="adc_ovr" num_pins="1" is_input="true"/&gt;
      &lt;port name="adc_samples" num_pins="32" is_output="true"/&gt;
      &lt;port name="sample_valid" num_pins="1" is_output="true"/&gt;
      &lt;port name="overflow_detect" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="adc_interface"/&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_adc_to_model" input="adc_interface_block.clk_adc" output="adc_interface.clk_adc"/&gt;
          &lt;direct name="rst_n_to_model" input="adc_interface_block.rst_n" output="adc_interface.rst_n"/&gt;
          &lt;direct name="adc_data_to_model" input="adc_interface_block.adc_data" output="adc_interface.adc_data"/&gt;
          &lt;direct name="adc_valid_to_model" input="adc_interface_block.adc_valid" output="adc_interface.adc_valid"/&gt;
          &lt;direct name="adc_ovr_to_model" input="adc_interface_block.adc_ovr" output="adc_interface.adc_ovr"/&gt;
          &lt;direct name="model_to_adc_samples" input="adc_interface.adc_samples" output="adc_interface_block.adc_samples"/&gt;
          &lt;direct name="model_to_sample_valid" input="adc_interface.sample_valid" output="adc_interface_block.sample_valid"/&gt;
          &lt;direct name="model_to_overflow_detect" input="adc_interface.overflow_detect" output="adc_interface_block.overflow_detect"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Asynchronous FIFO --&gt;
    &lt;pb_type name="async_fifo_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="wr_clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rd_clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="wr_rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="rd_rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="din" num_pins="32" is_input="true"/&gt;
      &lt;port name="wr_en" num_pins="1" is_input="true"/&gt;
      &lt;port name="rd_en" num_pins="1" is_input="true"/&gt;
      &lt;port name="dout" num_pins="32" is_output="true"/&gt;
      &lt;port name="full" num_pins="1" is_output="true"/&gt;
      &lt;port name="empty" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="async_fifo"&gt;
            &lt;param name="WIDTH" value="32"/&gt;
            &lt;param name="DEPTH" value="256"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="wr_clk_to_model" input="async_fifo_block.wr_clk" output="async_fifo.wr_clk"/&gt;
          &lt;direct name="rd_clk_to_model" input="async_fifo_block.rd_clk" output="async_fifo.rd_clk"/&gt;
          &lt;direct name="wr_rst_n_to_model" input="async_fifo_block.wr_rst_n" output="async_fifo.wr_rst_n"/&gt;
          &lt;direct name="rd_rst_n_to_model" input="async_fifo_block.rd_rst_n" output="async_fifo.rd_rst_n"/&gt;
          &lt;direct name="din_to_model" input="async_fifo_block.din" output="async_fifo.din"/&gt;
          &lt;direct name="wr_en_to_model" input="async_fifo_block.wr_en" output="async_fifo.wr_en"/&gt;
          &lt;direct name="rd_en_to_model" input="async_fifo_block.rd_en" output="async_fifo.rd_en"/&gt;
          &lt;direct name="model_to_dout" input="async_fifo.dout" output="async_fifo_block.dout"/&gt;
          &lt;direct name="model_to_full" input="async_fifo.full" output="async_fifo_block.full"/&gt;
          &lt;direct name="model_to_empty" input="async_fifo.empty" output="async_fifo_block.empty"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Digital Downconverter --&gt;
    &lt;pb_type name="digital_downconverter_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="adc_data" num_pins="32" is_input="true"/&gt;
      &lt;port name="data_valid" num_pins="1" is_input="true"/&gt;
      &lt;port name="nco_sine" num_pins="16" is_input="true"/&gt;
      &lt;port name="nco_cosine" num_pins="16" is_input="true"/&gt;
      &lt;port name="gain_control" num_pins="8" is_input="true"/&gt;
      &lt;port name="i_component" num_pins="32" is_output="true"/&gt;
      &lt;port name="q_component" num_pins="32" is_output="true"/&gt;
      &lt;port name="ddc_valid" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="digital_downconverter"&gt;
            &lt;param name="WIDTH" value="32"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_to_model" input="digital_downconverter_block.clk" output="digital_downconverter.clk"/&gt;
          &lt;direct name="rst_n_to_model" input="digital_downconverter_block.rst_n" output="digital_downconverter.rst_n"/&gt;
          &lt;direct name="adc_data_to_model" input="digital_downconverter_block.adc_data" output="digital_downconverter.adc_data"/&gt;
          &lt;direct name="data_valid_to_model" input="digital_downconverter_block.data_valid" output="digital_downconverter.data_valid"/&gt;
          &lt;direct name="nco_sine_to_model" input="digital_downconverter_block.nco_sine" output="digital_downconverter.nco_sine"/&gt;
          &lt;direct name="nco_cosine_to_model" input="digital_downconverter_block.nco_cosine" output="digital_downconverter.nco_cosine"/&gt;
          &lt;direct name="gain_control_to_model" input="digital_downconverter_block.gain_control" output="digital_downconverter.gain_control"/&gt;
          &lt;direct name="model_to_i_component" input="digital_downconverter.i_component" output="digital_downconverter_block.i_component"/&gt;
          &lt;direct name="model_to_q_component" input="digital_downconverter.q_component" output="digital_downconverter_block.q_component"/&gt;
          &lt;direct name="model_to_ddc_valid" input="digital_downconverter.ddc_valid" output="digital_downconverter_block.ddc_valid"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for NCO Generator --&gt;
    &lt;pb_type name="nco_generator_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="frequency_word" num_pins="32" is_input="true"/&gt;
      &lt;port name="enable" num_pins="1" is_input="true"/&gt;
      &lt;port name="sine_out" num_pins="16" is_output="true"/&gt;
      &lt;port name="cosine_out" num_pins="16" is_output="true"/&gt;
      &lt;port name="valid_out" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="nco_generator"&gt;
            &lt;param name="WIDTH" value="32"/&gt;
            &lt;param name="ROM_DEPTH" value="256"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_to_model" input="nco_generator_block.clk" output="nco_generator.clk"/&gt;
          &lt;direct name="rst_n_to_model" input="nco_generator_block.rst_n" output="nco_generator.rst_n"/&gt;
          &lt;direct name="frequency_word_to_model" input="nco_generator_block.frequency_word" output="nco_generator.frequency_word"/&gt;
          &lt;direct name="enable_to_model" input="nco_generator_block.enable" output="nco_generator.enable"/&gt;
          &lt;direct name="model_to_sine_out" input="nco_generator.sine_out" output="nco_generator_block.sine_out"/&gt;
          &lt;direct name="model_to_cosine_out" input="nco_generator.cosine_out" output="nco_generator_block.cosine_out"/&gt;
          &lt;direct name="model_to_valid_out" input="nco_generator.valid_out" output="nco_generator_block.valid_out"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Adaptive Gain Scaler --&gt;
    &lt;pb_type name="adaptive_gain_scaler_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="sample_in" num_pins="32" is_input="true"/&gt;
      &lt;port name="sample_valid_in" num_pins="1" is_input="true"/&gt;
      &lt;port name="gain_control" num_pins="8" is_input="true"/&gt;
      &lt;port name="sample_out" num_pins="32" is_output="true"/&gt;
      &lt;port name="sample_valid_out" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="adaptive_gain_scaler"&gt;
            &lt;param name="DATA_WIDTH" value="32"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_to_model" input="adaptive_gain_scaler_block.clk" output="adaptive_gain_scaler.clk"/&gt;
          &lt;direct name="rst_n_to_model" input="adaptive_gain_scaler_block.rst_n" output="adaptive_gain_scaler.rst_n"/&gt;
          &lt;direct name="sample_in_to_model" input="adaptive_gain_scaler_block.sample_in" output="adaptive_gain_scaler.sample_in"/&gt;
          &lt;direct name="sample_valid_in_to_model" input="adaptive_gain_scaler_block.sample_valid_in" output="adaptive_gain_scaler.sample_valid_in"/&gt;
          &lt;direct name="gain_control_to_model" input="adaptive_gain_scaler_block.gain_control" output="adaptive_gain_scaler.gain_control"/&gt;
          &lt;direct name="model_to_sample_out" input="adaptive_gain_scaler.sample_out" output="adaptive_gain_scaler_block.sample_out"/&gt;
          &lt;direct name="model_to_sample_valid_out" input="adaptive_gain_scaler.sample_valid_out" output="adaptive_gain_scaler_block.sample_valid_out"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for CIC Decimator --&gt;
    &lt;pb_type name="cic_decimator_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="data_in" num_pins="32" is_input="true"/&gt;
      &lt;port name="data_valid" num_pins="1" is_input="true"/&gt;
      &lt;port name="data_out" num_pins="32" is_output="true"/&gt;
      &lt;port name="output_valid" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="cic_decimator"&gt;
            &lt;param name="INPUT_WIDTH" value="32"/&gt;
            &lt;param name="OUTPUT_WIDTH" value="32"/&gt;
            &lt;param name="STAGES" value="3"/&gt;
            &lt;param name="DECIMATION" value="8"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_to_model" input="cic_decimator_block.clk" output="cic_decimator.clk"/&gt;
          &lt;direct name="rst_n_to_model" input="cic_decimator_block.rst_n" output="cic_decimator.rst_n"/&gt;
          &lt;direct name="data_in_to_model" input="cic_decimator_block.data_in" output="cic_decimator.data_in"/&gt;
          &lt;direct name="data_valid_to_model" input="cic_decimator_block.data_valid" output="cic_decimator.data_valid"/&gt;
          &lt;direct name="model_to_data_out" input="cic_decimator.data_out" output="cic_decimator_block.data_out"/&gt;
          &lt;direct name="model_to_output_valid" input="cic_decimator.output_valid" output="cic_decimator_block.output_valid"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Compensation Filter --&gt;
    &lt;pb_type name="compensation_filter_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="data_in" num_pins="32" is_input="true"/&gt;
      &lt;port name="data_valid" num_pins="1" is_input="true"/&gt;
      &lt;port name="data_out" num_pins="32" is_output="true"/&gt;
      &lt;port name="output_valid" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="compensation_filter"&gt;
            &lt;param name="WIDTH" value="32"/&gt;
            &lt;param name="COEFF_WIDTH" value="16"/&gt;
            &lt;param name="TAPS" value="8"/&gt;
            &lt;param name="DECIMATION" value="8"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_to_model" input="compensation_filter_block.clk" output="compensation_filter.clk"/&gt;
          &lt;direct name="rst_n_to_model" input="compensation_filter_block.rst_n" output="compensation_filter.rst_n"/&gt;
          &lt;direct name="data_in_to_model" input="compensation_filter_block.data_in" output="compensation_filter.data_in"/&gt;
          &lt;direct name="data_valid_to_model" input="compensation_filter_block.data_valid" output="compensation_filter.data_valid"/&gt;
          &lt;direct name="model_to_data_out" input="compensation_filter.data_out" output="compensation_filter_block.data_out"/&gt;
          &lt;direct name="model_to_output_valid" input="compensation_filter.output_valid" output="compensation_filter_block.output_valid"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Hamming Window --&gt;
    &lt;pb_type name="hamming_window_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="data_in" num_pins="32" is_input="true"/&gt;
      &lt;port name="data_valid" num_pins="1" is_input="true"/&gt;
      &lt;port name="data_out" num_pins="32" is_output="true"/&gt;
      &lt;port name="output_valid" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="hamming_window"&gt;
            &lt;param name="WIDTH" value="32"/&gt;
            &lt;param name="FFT_SIZE" value="1024"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_to_model" input="hamming_window_block.clk" output="hamming_window.clk"/&gt;
          &lt;direct name="rst_n_to_model" input="hamming_window_block.rst_n" output="hamming_window.rst_n"/&gt;
          &lt;direct name="data_in_to_model" input="hamming_window_block.data_in" output="hamming_window.data_in"/&gt;
          &lt;direct name="data_valid_to_model" input="hamming_window_block.data_valid" output="hamming_window.data_valid"/&gt;
          &lt;direct name="model_to_data_out" input="hamming_window.data_out" output="hamming_window_block.data_out"/&gt;
          &lt;direct name="model_to_output_valid" input="hamming_window.output_valid" output="hamming_window_block.output_valid"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for FFT Processor --&gt;
    &lt;pb_type name="fft_processor_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="real_in" num_pins="24" is_input="true"/&gt;
      &lt;port name="imag_in" num_pins="24" is_input="true"/&gt;
      &lt;port name="data_valid" num_pins="1" is_input="true"/&gt;
      &lt;port name="real_out" num_pins="24" is_output="true"/&gt;
      &lt;port name="imag_out" num_pins="24" is_output="true"/&gt;
      &lt;port name="fft_valid" num_pins="1" is_output="true"/&gt;
      &lt;port name="fft_index" num_pins="12" is_output="true"/&gt;
      &lt;port name="overflow_flag" num_pins="1" is_output="true"/&gt;
      &lt;port name="processing_active" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="fft_processor"&gt;
            &lt;param name="FFT_SIZE" value="4096"/&gt;
            &lt;param name="DATA_WIDTH" value="24"/&gt;
            &lt;param name="SCALE_FACTOR" value="24"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_to_model" input="fft_processor_block.clk" output="fft_processor.clk"/&gt;
          &lt;direct name="rst_n_to_model" input="fft_processor_block.rst_n" output="fft_processor.rst_n"/&gt;
          &lt;direct name="real_in_to_model" input="fft_processor_block.real_in" output="fft_processor.real_in"/&gt;
          &lt;direct name="imag_in_to_model" input="fft_processor_block.imag_in" output="fft_processor.imag_in"/&gt;
          &lt;direct name="data_valid_to_model" input="fft_processor_block.data_valid" output="fft_processor.data_valid"/&gt;
          &lt;direct name="model_to_real_out" input="fft_processor.real_out" output="fft_processor_block.real_out"/&gt;
          &lt;direct name="model_to_imag_out" input="fft_processor.imag_out" output="fft_processor_block.imag_out"/&gt;
          &lt;direct name="model_to_fft_valid" input="fft_processor.fft_valid" output="fft_processor_block.fft_valid"/&gt;
          &lt;direct name="model_to_fft_index" input="fft_processor.fft_index" output="fft_processor_block.fft_index"/&gt;
          &lt;direct name="model_to_overflow_flag" input="fft_processor.overflow_flag" output="fft_processor_block.overflow_flag"/&gt;
          &lt;direct name="model_to_processing_active" input="fft_processor.processing_active" output="fft_processor_block.processing_active"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for UDP/IP Stack --&gt;
    &lt;pb_type name="udp_ip_stack_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="app_data" num_pins="32" is_input="true"/&gt;
      &lt;port name="app_len" num_pins="16" is_input="true"/&gt;
      &lt;port name="app_valid" num_pins="1" is_input="true"/&gt;
      &lt;port name="src_ip" num_pins="32" is_input="true"/&gt;
      &lt;port name="dst_ip" num_pins="32" is_input="true"/&gt;
      &lt;port name="src_port" num_pins="16" is_input="true"/&gt;
      &lt;port name="dst_port" num_pins="16" is_input="true"/&gt;
      &lt;port name="app_ready" num_pins="1" is_output="true"/&gt;
      &lt;port name="mac_data" num_pins="32" is_output="true"/&gt;
      &lt;port name="mac_len" num_pins="16" is_output="true"/&gt;
      &lt;port name="mac_valid" num_pins="1" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="udp_ip_stack"&gt;
            &lt;param name="DATA_WIDTH" value="32"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_to_model" input="udp_ip_stack_block.clk" output="udp_ip_stack.clk"/&gt;
          &lt;direct name="rst_n_to_model" input="udp_ip_stack_block.rst_n" output="udp_ip_stack.rst_n"/&gt;
          &lt;direct name="app_data_to_model" input="udp_ip_stack_block.app_data" output="udp_ip_stack.app_data"/&gt;
          &lt;direct name="app_len_to_model" input="udp_ip_stack_block.app_len" output="udp_ip_stack.app_len"/&gt;
          &lt;direct name="app_valid_to_model" input="udp_ip_stack_block.app_valid" output="udp_ip_stack.app_valid"/&gt;
          &lt;direct name="src_ip_to_model" input="udp_ip_stack_block.src_ip" output="udp_ip_stack.src_ip"/&gt;
          &lt;direct name="dst_ip_to_model" input="udp_ip_stack_block.dst_ip" output="udp_ip_stack.dst_ip"/&gt;
          &lt;direct name="src_port_to_model" input="udp_ip_stack_block.src_port" output="udp_ip_stack.src_port"/&gt;
          &lt;direct name="dst_port_to_model" input="udp_ip_stack_block.dst_port" output="udp_ip_stack.dst_port"/&gt;
          &lt;direct name="model_to_app_ready" input="udp_ip_stack.app_ready" output="udp_ip_stack_block.app_ready"/&gt;
          &lt;direct name="model_to_mac_data" input="udp_ip_stack.mac_data" output="udp_ip_stack_block.mac_data"/&gt;
          &lt;direct name="model_to_mac_len" input="udp_ip_stack.mac_len" output="udp_ip_stack_block.mac_len"/&gt;
          &lt;direct name="model_to_mac_valid" input="udp_ip_stack.mac_valid" output="udp_ip_stack_block.mac_valid"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for Ethernet MAC Layer --&gt;
    &lt;pb_type name="ethernet_mac_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="rst_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="gmii_rx_d" num_pins="8" is_input="true"/&gt;
      &lt;port name="gmii_rx_dv" num_pins="1" is_input="true"/&gt;
      &lt;port name="gmii_rx_er" num_pins="1" is_input="true"/&gt;
      &lt;port name="packet_data" num_pins="32" is_input="true"/&gt;
      &lt;port name="packet_len" num_pins="16" is_input="true"/&gt;
      &lt;port name="packet_valid" num_pins="1" is_input="true"/&gt;
      &lt;port name="rx_packet_ack" num_pins="1" is_input="true"/&gt;
      &lt;port name="gmii_tx_d" num_pins="8" is_output="true"/&gt;
      &lt;port name="gmii_tx_en" num_pins="1" is_output="true"/&gt;
      &lt;port name="gmii_tx_er" num_pins="1" is_output="true"/&gt;
      &lt;port name="packet_ack" num_pins="1" is_output="true"/&gt;
      &lt;port name="rx_packet_data" num_pins="32" is_output="true"/&gt;
      &lt;port name="rx_packet_len" num_pins="16" is_output="true"/&gt;
      &lt;port name="rx_packet_valid" num_pins="1" is_output="true"/&gt;
      &lt;port name="link_status" num_pins="1" is_output="true"/&gt;
      &lt;port name="packet_counter" num_pins="32" is_output="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="ethernet_mac"&gt;
            &lt;param name="DATA_WIDTH" value="32"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="clk_to_model" input="ethernet_mac_block.clk" output="ethernet_mac.clk"/&gt;
          &lt;direct name="rst_n_to_model" input="ethernet_mac_block.rst_n" output="ethernet_mac.rst_n"/&gt;
          &lt;direct name="gmii_rx_d_to_model" input="ethernet_mac_block.gmii_rx_d" output="ethernet_mac.gmii_rx_d"/&gt;
          &lt;direct name="gmii_rx_dv_to_model" input="ethernet_mac_block.gmii_rx_dv" output="ethernet_mac.gmii_rx_dv"/&gt;
          &lt;direct name="gmii_rx_er_to_model" input="ethernet_mac_block.gmii_rx_er" output="ethernet_mac.gmii_rx_er"/&gt;
          &lt;direct name="packet_data_to_model" input="ethernet_mac_block.packet_data" output="ethernet_mac.packet_data"/&gt;
          &lt;direct name="packet_len_to_model" input="ethernet_mac_block.packet_len" output="ethernet_mac.packet_len"/&gt;
          &lt;direct name="packet_valid_to_model" input="ethernet_mac_block.packet_valid" output="ethernet_mac.packet_valid"/&gt;
          &lt;direct name="rx_packet_ack_to_model" input="ethernet_mac_block.rx_packet_ack" output="ethernet_mac.rx_packet_ack"/&gt;
          &lt;direct name="model_to_gmii_tx_d" input="ethernet_mac.gmii_tx_d" output="ethernet_mac_block.gmii_tx_d"/&gt;
          &lt;direct name="model_to_gmii_tx_en" input="ethernet_mac.gmii_tx_en" output="ethernet_mac_block.gmii_tx_en"/&gt;
          &lt;direct name="model_to_gmii_tx_er" input="ethernet_mac.gmii_tx_er" output="ethernet_mac_block.gmii_tx_er"/&gt;
          &lt;direct name="model_to_packet_ack" input="ethernet_mac.packet_ack" output="ethernet_mac_block.packet_ack"/&gt;
          &lt;direct name="model_to_rx_packet_data" input="ethernet_mac.rx_packet_data" output="ethernet_mac_block.rx_packet_data"/&gt;
          &lt;direct name="model_to_rx_packet_len" input="ethernet_mac.rx_packet_len" output="ethernet_mac_block.rx_packet_len"/&gt;
          &lt;direct name="model_to_rx_packet_valid" input="ethernet_mac.rx_packet_valid" output="ethernet_mac_block.rx_packet_valid"/&gt;
          &lt;direct name="model_to_link_status" input="ethernet_mac.link_status" output="ethernet_mac_block.link_status"/&gt;
          &lt;direct name="model_to_packet_counter" input="ethernet_mac.packet_counter" output="ethernet_mac_block.packet_counter"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;

    &lt;!-- Custom IP block for RP2040 Interface --&gt;
    &lt;pb_type name="rp2040_interface_block" num_pb="1" class="custom_hard_block" is_primitive="true"&gt;
      &lt;port name="spi_clk" num_pins="1" is_input="true" is_clock="true"/&gt;
      &lt;port name="spi_mosi" num_pins="1" is_input="true"/&gt;
      &lt;port name="spi_cs_n" num_pins="1" is_input="true"/&gt;
      &lt;port name="spi_miso" num_pins="1" is_output="true"/&gt;
      &lt;port name="frequency_word" num_pins="32" is_output="true"/&gt;
      &lt;port name="gain_control" num_pins="8" is_output="true"/&gt;
      &lt;port name="filter_select" num_pins="4" is_output="true"/&gt;
      &lt;port name="enable_control" num_pins="1" is_output="true"/&gt;
      &lt;port name="streaming_mode" num_pins="1" is_output="true"/&gt;
      &lt;port name="bandwidth_limit" num_pins="8" is_output="true"/&gt;
      &lt;port name="processing_mode" num_pins="3" is_output="true"/&gt;
      &lt;port name="modulation_type" num_pins="8" is_output="true"/&gt;
      &lt;port name="filter_bandwidth" num_pins="8" is_output="true"/&gt;
      &lt;port name="clock_gating_en" num_pins="1" is_output="true"/&gt;
      &lt;port name="thermal_scaling" num_pins="8" is_output="true"/&gt;
      &lt;port name="resource_opt_en" num_pins="1" is_output="true"/&gt;
      &lt;port name="power_profile" num_pins="8" is_output="true"/&gt;
      &lt;port name="status_reg" num_pins="16" is_input="true"/&gt;
      &lt;port name="pll_locked" num_pins="1" is_input="true"/&gt;
      &lt;port name="eth_link_status" num_pins="1" is_input="true"/&gt;
      &lt;mode name="default"&gt;
        &lt;model_list&gt;
          &lt;model name="rp2040_interface"&gt;
            &lt;param name="ADDR_WIDTH" value="16"/&gt;
            &lt;param name="DATA_WIDTH" value="32"/&gt;
          &lt;/model&gt;
        &lt;/model_list&gt;
        &lt;interconnect&gt;
          &lt;direct name="spi_clk_to_model" input="rp2040_interface_block.spi_clk" output="rp2040_interface.spi_clk"/&gt;
          &lt;direct name="spi_mosi_to_model" input="rp2040_interface_block.spi_mosi" output="rp2040_interface.spi_mosi"/&gt;
          &lt;direct name="spi_cs_n_to_model" input="rp2040_interface_block.spi_cs_n" output="rp2040_interface.spi_cs_n"/&gt;
          &lt;direct name="model_to_spi_miso" input="rp2040_interface.spi_miso" output="rp2040_interface_block.spi_miso"/&gt;
          &lt;direct name="model_to_frequency_word" input="rp2040_interface.frequency_word" output="rp2040_interface_block.frequency_word"/&gt;
          &lt;direct name="model_to_gain_control" input="rp2040_interface.gain_control" output="rp2040_interface_block.gain_control"/&gt;
          &lt;direct name="model_to_filter_select" input="rp2040_interface.filter_select" output="rp2040_interface_block.filter_select"/&gt;
          &lt;direct name="model_to_enable_control" input="rp2040_interface.enable_control" output="rp2040_interface_block.enable_control"/&gt;
          &lt;direct name="model_to_streaming_mode" input="rp2040_interface.streaming_mode" output="rp2040_interface_block.streaming_mode"/&gt;
          &lt;direct name="model_to_bandwidth_limit" input="rp2040_interface.bandwidth_limit" output="rp2040_interface_block.bandwidth_limit"/&gt;
          &lt;direct name="model_to_processing_mode" input="rp2040_interface.processing_mode" output="rp2040_interface_block.processing_mode"/&gt;
          &lt;direct name="model_to_modulation_type" input="rp2040_interface.modulation_type" output="rp2040_interface_block.modulation_type"/&gt;
          &lt;direct name="model_to_filter_bandwidth" input="rp2040_interface.filter_bandwidth" output="rp2040_interface_block.filter_bandwidth"/&gt;
          &lt;direct name="model_to_clock_gating_en" input="rp2040_interface.clock_gating_en" output="rp2040_interface_block.clock_gating_en"/&gt;
          &lt;direct name="model_to_thermal_scaling" input="rp2040_interface.thermal_scaling" output="rp2040_interface_block.thermal_scaling"/&gt;
          &lt;direct name="model_to_resource_opt_en" input="rp2040_interface.resource_opt_en" output="rp2040_interface_block.resource_opt_en"/&gt;
          &lt;direct name="model_to_power_profile" input="rp2040_interface.power_profile" output="rp2040_interface_block.power_profile"/&gt;
          &lt;direct name="status_reg_to_model" input="rp2040_interface_block.status_reg" output="rp2040_interface.status_reg"/&gt;
          &lt;direct name="pll_locked_to_model" input="rp2040_interface_block.pll_locked" output="rp2040_interface.pll_locked"/&gt;
          &lt;direct name="eth_link_status_to_model" input="rp2040_interface_block.eth_link_status" output="rp2040_interface.eth_link_status"/&gt;
        &lt;/interconnect&gt;
      &lt;/mode&gt;
    &lt;/pb_type&gt;
  &lt;/block_types&gt;

  &lt;!-- Define FPGA grid layout --&gt;
  &lt;layout&gt;
    &lt;fixed_layout name="4x4_grid" priority="1" num_rows="4" num_cols="4"&gt;
      &lt;apply block_type="io" num_instances="1" side="left"  startx="0" starty="1"/&gt;
      &lt;apply block_type="io" num_instances="1" side="right" startx="4" starty="1"/&gt;
      &lt;apply block_type="CLB" num_instances="1" startx="1" starty="1"/&gt;
      &lt;apply block_type="CLB" num_instances="1" startx="2" starty="1"/&gt;
      &lt;apply block_type="CLB" num_instances="1" startx="1" starty="2"/&gt;
      &lt;apply block_type="CLB" num_instances="1" startx="2" starty="2"/&gt;
    &lt;/fixed_layout&gt;
  &lt;/layout&gt;

  &lt;!-- Define global routing architecture --&gt;
  &lt;segment_library&gt;
    &lt;segment name="L4" length="4" type="bidir" R_per_meter="80" C_per_meter="2.5e-14" freq_typical="100e6"&gt;
      &lt;mux name="mux_2" type="full_mux"/&gt;
      &lt;driver name="tgate" type="pmos"/&gt;
      &lt;sb_switch name="0" type="pass_gate"/&gt;
      &lt;cb_switch name="0" type="pass_gate"/&gt;
    &lt;/segment&gt;
  &lt;/segment_library&gt;
  
  &lt;switch_library&gt;
    &lt;switch name="0" type="mux" R="50" Cin="0" Cout="0" Tdel="0"/&gt;
  &lt;/switch_library&gt;
  
  &lt;tool_options&gt;
    &lt;sdc_options&gt;
      &lt;time_unit value="ns"/&gt;
    &lt;/sdc_options&gt;
  &lt;/tool_options&gt;

&lt;/openfpga_architecture&gt;
